-- -*- mode: lua -*-

configPoints = {
    series = {
        short = "Device series being used",
        long = "The devices series for which the library will be compiled",
        help = [[
The XUD library supports both the U-Series and L-Series devices. The library provides
binaries for each device series. However, the tools currently don't fully support
changing libraries and will hence require the user to make a change to the Makefile
if they change from the default series.
                ]],
        type = "string",
        default = "U-Series",
        options = { ["U-Series"] = 1, ["L-Series"] = 2},
        define = "XUD_DEVICE_SERIES"
    }
}

derivedValues = {}

ports = {}

reset_port = ""
if swblock.params.series == "2" then
  -- L-Series
  reset_port = reset_port .. "/* USB Port declarations */\n"
  reset_port = reset_port .. "#define USB_RST_PORT    XS1_PORT_32A\n"
  reset_port = reset_port .. "on tile[0]: out port p_usb_rst   = USB_RST_PORT;\n"
  reset_port = reset_port .. "on tile[0]: clock    clk_usb_rst = XS1_CLKBLK_3;\n"

else
  -- U-Series
  reset_port = reset_port .. "#define p_usb_rst null\n"
  reset_port = reset_port .. "#define clk_usb_rst null\n"
end

channels = {
   c_ep_out = {
      short = "OUT endpoint channels",
      long = "Channels for communicating with OUT endpoints",
      help = "",
      arraySize = 1
   },
   c_ep_in = {
      short = "IN endpoint channels",
      long = "Channel for communicating with IN endpoints",
      help = "",
      arraySize = 2
   }
}

function getConfigStatus()
   return "Trusted", {}
end

generatedCode = {
   includes = {"usb.h", "xud.h", "usb_device.h", "hid.h"},
   globals  = 
       [[
#define XUD_EP_COUNT_OUT 1
#define XUD_EP_COUNT_IN  2

/* Endpoint type tables */
XUD_EpType epTypeTableOut[XUD_EP_COUNT_OUT] = {XUD_EPTYPE_CTL | XUD_STATUS_ENABLE};
XUD_EpType epTypeTableIn[XUD_EP_COUNT_IN] =   {XUD_EPTYPE_CTL | XUD_STATUS_ENABLE, XUD_EPTYPE_BUL};

${reset_port}

#ifndef VENDOR_ID
#define VENDOR_ID 0x20B1
#warning VENDOR_ID not defined, using XMOS vendor ID
#endif

#ifndef PRODUCT_ID
#define PRODUCT_ID 0x0001
#warning PRODUCT_ID not defined using 0x0001 as a default
#endif

#ifndef BCD_DEVICE
#define BCD_DEVICE 0x0000
#warning BCD_DEVICE not defines, using 0x0000
#endif

#ifndef MANUFACTURER_STR_INDEX
#define MANUFACTURER_STR_INDEX 0x0001
#warning MANUFACTURER_STR_INDEX not defined, using 0x0001
#endif

#ifndef PRODUCT_STR_INDEX
#define PRODUCT_STR_INDEX 0x0002
#warning PRODUCT_STR_INDEX not defined, using 0x0002
#endif

unsigned char devDesc_Null[] = 
{
    18,                             /* 0  bLength : Size of descriptor in Bytes (18 Bytes) */ 
    USB_DEVICE,                     /* 1  bdescriptorType */ 
    0,                              /* 2  bcdUSB */ 
    2,                              /* 3  bcdUSB */ 
    0x0,                            /* 4  bDeviceClass */ 
    0x0,                            /* 5  bDeviceSubClass */ 
    0x00,                           /* 6  bDeviceProtocol */ 
    64,                             /* 7  bMaxPacketSize */ 
    (VENDOR_ID & 0xFF),             /* 8  idVendor */ 
    (VENDOR_ID >> 8),               /* 9  idVendor */ 
    (PRODUCT_ID & 0xFF),            /* 10 idProduct */ 
    (PRODUCT_ID >> 8),              /* 11 idProduct */ 
    (BCD_DEVICE & 0xFF),            /* 12 bcdDevice : Device release number */ 
    (BCD_DEVICE >> 8),              /* 13 bcdDevice : Device release number */ 
    MANUFACTURER_STR_INDEX,         /* 14 iManufacturer : Index of manufacturer string */ 
    PRODUCT_STR_INDEX,              /* 15 iProduct : Index of product string descriptor */ 
    0,//SERIAL_STR_INDEX,           /* 16 iSerialNumber : Index of serial number decriptor */ 
    0x01                            /* 17 bNumConfigurations : Number of possible configs */
};

unsigned char cfgDesc_Null[] = 
{
    0x09,                           /* 0  bLength */
    USB_CONFIGURATION,              /* 1  bDescriptorType */
    0x12,                           /* 2  wTotalLength */
    0x00,                           /* 3  wTotalLength */
    0x01,                           /* 4  bNumInterface: Number of interfaces*/
    0x01,                           /* 5  bConfigurationValue */
    0x00,                           /* 6  iConfiguration */
#ifdef SELF_POWERED
    192,                            /* 7  bmAttributes */
    0,                              /* 8  bMaxPower */
#else
    128, 
    250,                            /* 8  bMaxPower */
#endif
    0x09,                           /* 0 bLength : Size of this descriptor, in bytes. (field size 1 bytes) */
    0x04,                           /* 1 bDescriptorType : INTERFACE descriptor. (field size 1 bytes) */
    0x00,                           /* 2 bInterfaceNumber : Index of this interface. (field size 1 bytes) */
    0x00,                           /* 3 bAlternateSetting : Index of this setting. (field size 1 bytes) */
    0x00,                           /* 4 bNumEndpoints : 0 endpoints. (field size 1 bytes) */
    0x00,                           /* 5 bInterfaceClass :  */
    0x00,                           /* 6 bInterfaceSubclass */
    0x00,                           /* 7 bInterfaceProtocol : Unused. (field size 1 bytes) */
    0x00,                           /* 8 iInterface : Unused. (field size 1 bytes) */
    0x09,                           /* 0  bLength */ 
};

/* String table */
static unsigned char stringDescriptors[][40] = 
{
    "\\004\\009",               // Language string
    "XMOS",                     // iManufacturer 
    "Empty Device",             // iProduct
    "",                         // unUsed
    "Config",                   // iConfiguration
};

void Endpoint0(chanend chan_ep0_out, chanend chan_ep0_in, chanend ?c_usb_test)
{
    USB_SetupPacket_t sp;

    unsigned bmRequestType; 
    XUD_BusSpeed usbBusSpeed;
    
    XUD_ep ep0_out = XUD_InitEp(chan_ep0_out);
    XUD_ep ep0_in  = XUD_InitEp(chan_ep0_in);
    
    while (1)
    {
        /* Returns 0 on success, < 0 for USB RESET */
        int retVal = USB_GetSetupPacket(ep0_out, ep0_in, sp);
        
        if (!retVal) 
        {
            retVal = 1;

            /* Stick bmRequest type back together for an easier parse... */
            bmRequestType = (sp.bmRequestType.Direction << 7) |
                            (sp.bmRequestType.Type << 5) |
                            (sp.bmRequestType.Recipient);
    
            switch (bmRequestType)
            {
                case USB_BMREQ_D2H_STANDARD_INT:
 
                    if (sp.bRequest == USB_GET_DESCRIPTOR)
                    {
                        /* HID Interface is Interface 0 */
                        if (sp.wIndex == 0)
                        {
                            /* Look at Descriptor Type (high-byte of wValue) */ 
                            unsigned short descriptorType = sp.wValue & 0xff00;
            
                            switch (descriptorType)
                            {
                                case HID_HID:
                                    /* Enable if supporting a HID device */
                                    /*retVal = XUD_DoGetRequest(ep0_out, ep0_in, hidDescriptor, 
                                        sizeof(hidDescriptor), sp.wLength);*/
                                    break;
                        
                                case HID_REPORT:
                                    /* Enable if supporting a HID device */
                                    /*retVal = XUD_DoGetRequest(ep0_out, ep0_in, hidReportDescriptor,
                                        sizeof(hidReportDescriptor), sp.wLength);*/
                                    break;
                            }
                        }
                    }
                    break;

                case USB_BMREQ_H2D_CLASS_INT:
                case USB_BMREQ_D2H_CLASS_INT:

                    /* If Implementing HID Class - handle HID Interface Class Request */
                    break;
            }
        }

        /* If we haven't handled the request about, 
         * then do standard enumeration requests  */
        if (retVal > 0)
        {
            /* Returns  0 if handled okay,
             *          1 if request was not handled (STALLed),
             *         -1 of USB Reset */
            retVal = USB_StandardRequests(ep0_out, ep0_in, devDesc_Null,
                        sizeof(devDesc_Null), cfgDesc_Null, sizeof(cfgDesc_Null),
                        null, 0, null, 0, stringDescriptors, sp,
                        c_usb_test, usbBusSpeed);
        }

        /* USB bus reset detected, reset EP and get new bus speed */
        if (retVal < 0)
        {
            usbBusSpeed = XUD_ResetEndpoint(ep0_out, ep0_in);
        }
    }
}

       ]],
   body  = 
       [[
    par {
        XUD_Manager(c_ep_out, XUD_EP_COUNT_OUT, c_ep_in, XUD_EP_COUNT_IN,
                                null, epTypeTableOut, epTypeTableIn,
                                p_usb_rst, clk_usb_rst, -1, XUD_SPEED_HS, null); 

        Endpoint0(c_ep_out[0], c_ep_in[0], null);
    }
       ]]
}

api = {
    "USB_StandardRequests",
    "USB_GetSetupPacket",
    "USB_PrintSetupPacket"
}
